package solution1

import "math"

func cherryPickup(grid [][]int) int {
	var (
		n  = len(grid)
		dp = make([][][]int, 2*n-1)
	)
	// 1. çŠ¶æ€å®šä¹‰
	// å°†é¢˜ç›®è½¬åŒ–ä¸º ä¸¤ä¸ªäººåŒæ—¶èµ°, åŒä¸€æ—¶åˆ» Aå¤„äºä½ç½®(x1, y1)  Bå‡ºäºæœªçŸ¥(x2, y2)
	// steps == x1 + y1 == x2 + y2
	// dp[k][x1][x2]:èµ°äº† k æ­¥, Aå¤„äºä½ç½®(x1, k-x1) Bå¤„äºä½ç½®(x2, k-x2) å¯ä»¥è·å–çš„æ¨±æ¡ƒğŸ’æ•°çš„æœ€å¤§å€¼
	// ç½—åˆ—å‡ºæ‰€æœ‰çš„å¯èƒ½æ€§.
	// 2. é€’æ¨å…¬å¼:
	// dp[k][x1][x2] = max((x1å‘å³, x2 å‘ä¸‹), (x1å‘ä¸‹, x2å‘ä¸‹), (x1å‘å³, x2å‘å³), (x1å‘å³, x2å‘ä¸‹))
	// dp[k][x1][x2] = max(dp[k-1][x1-1][x2], dp[k-1][x1-1][x2-1], dp[k-1][x1][x2], dp[k-1][x1][x2-1])

	// ... ä¸€äº›ç»†èŠ‚:

	// init state
	for i := range dp {
		dp[i] = make([][]int, n)
		for j := range dp[i] {
			dp[i][j] = make([]int, n)
			for k := range dp[i][j] {
				dp[i][j][k] = math.MinInt
			}
		}
	}
	dp[0][0][0] = grid[0][0]
	//
	for k := 1; k < 2*n-1; k++ {
		for x1 := max(k-n+1, 0); x1 <= min(k, n-1); x1++ {
			y1 := k - x1
			// skip
			if grid[x1][y1] == -1 {
				continue
			}
			// ? ä¸ºä»€ä¹ˆæ˜¯  x2 çš„åˆå§‹å€¼æ˜¯ x1
			// ä»£ç å®ç°æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å°† A å’Œ B èµ°å‡ºçš„è·¯å¾„çš„ä¸Šè½®å»“çœ‹æˆæ˜¯ A èµ°å‡ºçš„è·¯å¾„,ä¸‹è½®å»“çœ‹æˆæ˜¯ B èµ°å‡ºçš„è·¯å¾„,å³è§†ä½œ A å§‹ç»ˆä¸ä¼šèµ°åˆ° B çš„ä¸‹æ–¹.
			//  åˆ™æœ‰ x1â‰¤x2, åœ¨ä»£ç å®ç°æ—¶ä¿è¯è¿™ä¸€ç‚¹ï¼Œå¯ä»¥å‡å°‘å¾ªç¯æ¬¡æ•°.
			for x2 := x1; x2 <= min(k, n-1); x2++ {
				y2 := k - x2
				if grid[x2][y2] == -1 {
					continue
				}
				//3. (x1å‘å³, x2å‘å³),
				res := dp[k-1][x1][x2]
				//1. (x1å‘å³, x2 å‘ä¸‹),
				if x2 > 0 {
					res = max(res, dp[k-1][x1][x2-1])
				}
				//2. (x1å‘ä¸‹, x2å‘ä¸‹),
				if x1 > 0 && x2 > 0 {
					res = max(res, dp[k-1][x1-1][x2-1])
				}
				//4. (x1å‘å³, x2å‘ä¸‹)
				if x1 > 0 {
					res = max(res, dp[k-1][x1][x2-1])
				}
				res += grid[x1][y1]
				if x1 != x2 { // é¿å…é‡å¤
					res += grid[x2][y2]
				}
				dp[k][x1][x2] = res
			}
		}
	}
	return min(dp[2*n-2][n-1][n-1], 0)
}
